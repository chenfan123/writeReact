(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

	const HostRoot = 3; // 项目根节点

	const NoFlags = 0b0000001;

	class FiberNode {
	    /**
	     * @param tag 就是这个FiberNode是什么类型的节点
	     * @param pendingProps 就是当前fiber接下来有哪些Props需要改变
	     * @param key
	     */
	    type;
	    tag;
	    pendingProps;
	    key;
	    stateNode;
	    ref;
	    return;
	    sibling;
	    child;
	    index;
	    memoizedProps;
	    memoizedState;
	    alternate;
	    flags;
	    subtreeFlags;
	    updateQueue;
	    constructor(tag, pendingProps, key) {
	        // 实例
	        this.tag = tag;
	        this.key = key;
	        this.stateNode = null; // 对于HostComponent来说如果是个div，那么这个stateNode就保存了div的DOM
	        this.type = null; // fiberNode的类型，functionCom来说，type就是0
	        // 构成树状结构
	        this.return = null; // 指向父fiberNode
	        this.sibling = null; // 指向兄弟
	        this.child = null; // 指向子
	        this.index = 0; // 如果同级的fiberNode有好几个，第一个就是0，第二个就是1
	        this.ref = null;
	        // 作为工作单元
	        this.pendingProps = pendingProps; // 刚开始准备工作的时候props
	        this.memoizedProps = null; // 工作完之后的props
	        this.memoizedState = null;
	        this.updateQueue = null;
	        this.alternate = null; // 用于当前fiberNode与另一个fiberNode进行切换
	        // 副作用
	        this.flags = NoFlags; // 用于存储标记（删除、插入、移动等等）
	        this.subtreeFlags = NoFlags; // 子树中包含的flags
	    }
	}
	class FiberRootNode {
	    container;
	    current; // 指针指向hostRootFiber
	    finishedWork; // 指向更新完成之后的hostRootFiber
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        this.current = hostRootFiber;
	        hostRootFiber.stateNode = this; // hostRootFiber的stateNode指向fiberRootNode
	        this.finishedWork = null;
	    }
	}

	// 代表更新的数据结构Update
	const createUpdate = (action) => {
	    return {
	        action
	    };
	};
	//消费Update的数据结构UpdateQueue: UpdateQueue里面有一个shared.pending这个字段，这个字段指向update
	const createUpdateQueue = () => {
	    return {
	        shared: {
	            pending: null
	        }
	    };
	};
	// 往UpdateQueue里增加Update
	const enqueueUpdate = (updateQueue, update) => {
	    updateQueue.shared.pending = update;
	};

	// 在fiber中调度update，连接 container 和 renderRoot方法
	function scheduleUpdateOnFiber(fiber) {
	    // @TODO 调度功能
	    // 从当前更新的fiber遍历到fiberRootNode
	    markUpdateFromFiberToRoot(fiber);
	}
	// 从当前节点遍历到根节点
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        // !== null就说明当前节点是普通的fiberNode
	        node = parent;
	        parent = node.return;
	    }
	    // 跳出循环,一般就是到了hostRootFiber
	    if (node.tag === HostRoot) {
	        return node.stateNode; // 就是fiberRootNode
	    }
	    return null;
	}

	/**
	 * ReactDOM.createRoot().render()
	 * 调用createRoot()方法之后，内部会执行createContainer
	 */
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	/**
	 * ReactDOM.createRoot().render()
	 * 执行render方法之后，在render方法内部就会执行updateContainer方法
	 * 返回的element对于reactDom.createRoot(root).render(<App/>)来说，App组件对应的ReactElement就是这个element
	 */
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    const update = createUpdate(element); // 创建1个update，这次更新跟element相关的
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}

	// ReactDOM.createRoot(root).render(<App/>)
	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        }
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
